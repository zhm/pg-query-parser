{"version":3,"sources":["../src/index.js"],"names":["canRequire","name","require","resolve","e","whichParser","parser","parse","emscriptenParser","sql","err","error","stderr","stderr_buffer","query","parse_tree","message","funcname","filename","lineno","cursorpos","Error","fileName","lineNumber","cursorPosition","functionName","context","deparse","verify","result","json1","json2","JSON","stringify","walk","first","all","tables","byType","clean","Deparser"],"mappings":";;;;;;;AA6BA;;;;AACA;;;;AA9BA,SAASA,UAAT,CAAoBC,IAApB,EAA0B;AACxB,MAAI;AACF,WAAO,CAAC,CAACC,QAAQC,OAAR,CAAgBF,IAAhB,CAAT;AACD,GAFD,CAEE,OAAOG,CAAP,EAAU,CAAE,gBAAkB;AAChC,SAAO,KAAP;AACD;;AAED,MAAMC,cAAcL,WAAW,iBAAX,IAAgC,iBAAhC,GAAoD,qBAAxE;AACA,MAAMM,SAASJ,QAAQG,WAAR,EAAqBE,KAApC;AACA,IAAIA,QAAQD,MAAZ;AACA,IAAID,gBAAgB,qBAApB,EAA2C;AACzC,QAAMG,mBAAmBD,KAAzB;AACA;AACA,UA8BOA,KA9BP,WAASE,GAAD,IAAS;AAAA,4BACkDD,iBAAiBC,GAAjB,CADlD;;AAAA,UACAC,GADA,qBACPC,KADO;AAAA,UACoBC,MADpB,qBACKC,aADL;AAAA,UACwCC,KADxC,qBAC4BC,UAD5B;;AAEf,QAAIL,GAAJ,EAAS;AAAA,YACCM,OADD,GACoDN,GADpD,CACCM,OADD;AAAA,YACUC,QADV,GACoDP,GADpD,CACUO,QADV;AAAA,YACoBC,QADpB,GACoDR,GADpD,CACoBQ,QADpB;AAAA,YAC8BC,MAD9B,GACoDT,GADpD,CAC8BS,MAD9B;AAAA,YACsCC,SADtC,GACoDV,GADpD,CACsCU,SADtC;;AAEP,YAAMT,QAAQ,IAAIU,KAAJ,CAAUL,OAAV,CAAd;AACAL,YAAMW,QAAN,GAAiBJ,QAAjB;AACAP,YAAMY,UAAN,GAAmBJ,MAAnB;AACAR,YAAMa,cAAN,GAAuBJ,SAAvB;AACAT,YAAMc,YAAN,GAAqBR,QAArB;AACAN,YAAMe,OAAN,GAAgB,IAAhB;AACA,aAAO,EAAEf,YAAF,EAASG,YAAT,EAAP;AACD;AACD,WAAO,EAAEA,YAAF,EAASF,cAAT,EAAP;AACD,GAbD;AAcD;;AAKD,MAAMe,UAAU,mBAASA,OAAzB;;AAEA,MAAMC,SAAUd,KAAD,IAAW;AACxB,QAAMe,SAASF,QAAQpB,MAAMO,KAAN,EAAaA,KAArB,CAAf;;AAEA,QAAMgB,QAAQ,kBAAMvB,MAAMO,KAAN,EAAaA,KAAnB,CAAd;AACA,QAAMiB,QAAQ,kBAAMxB,MAAMsB,MAAN,EAAcf,KAApB,CAAd;;AAEA,SAAOkB,KAAKC,SAAL,CAAeH,KAAf,MAA0BE,KAAKC,SAAL,CAAeF,KAAf,CAAjC;AACD,CAPD;;QASSxB,K,GAAAA,K;QAAOoB,O,GAAAA,O;QAASO,I;QAAMC,K;QAAOC,G;QAAKC,M;QAAQC,M;QAAQC,K;QAAOX,M,GAAAA,M;QAAQY,Q","file":"index.js","sourcesContent":["function canRequire(name) {\n  try {\n    return !!require.resolve(name);\n  } catch (e) { /* do nothing */ }\n  return false;\n}\n\nconst whichParser = canRequire('pg-query-native') ? 'pg-query-native' : 'pg-query-emscripten';\nconst parser = require(whichParser).parse;\nlet parse = parser;\nif (whichParser === 'pg-query-emscripten') {\n  const emscriptenParser = parse;\n  // make the return of the emscripen parser be equivalent to the native parser\n  parse = (sql) => {\n    const { error: err, stderr_buffer: stderr, parse_tree: query } = emscriptenParser(sql);\n    if (err) {\n      const { message, funcname, filename, lineno, cursorpos } = err;\n      const error = new Error(message);\n      error.fileName = filename;\n      error.lineNumber = lineno;\n      error.cursorPosition = cursorpos;\n      error.functionName = funcname;\n      error.context = null;\n      return { error, query };\n    }\n    return { query, stderr };\n  };\n}\n\nimport Deparser from './deparser';\nimport { walk, all, first, tables, byType, clean } from './utils';\n\nconst deparse = Deparser.deparse;\n\nconst verify = (query) => {\n  const result = deparse(parse(query).query);\n\n  const json1 = clean(parse(query).query);\n  const json2 = clean(parse(result).query);\n\n  return JSON.stringify(json1) === JSON.stringify(json2);\n};\n\nexport { parse, deparse, walk, first, all, tables, byType, clean, verify, Deparser };\n"]}